<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Art Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0b;
            --card: #141416;
            --accent: #e8c547;
            --text: #f5f5f4;
            --dim: #8a8a8a;
            --border: #2a2a2d;
        }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        h1 {
            text-align: center;
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-bottom: 30px;
            color: var(--accent);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 30px;
        }
        @media (max-width: 800px) {
            .container { grid-template-columns: 1fr; }
        }
        .canvas-area {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }
        .canvases {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .canvas-box {
            position: relative;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
        }
        .canvas-box canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        .canvas-box span {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 11px;
            color: var(--dim);
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 3px;
        }
        .progress {
            margin-top: 15px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.1s;
        }
        .status {
            margin-top: 10px;
            font-size: 13px;
            color: var(--dim);
        }
        .status.active { color: var(--accent); }
        .controls {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-size: 11px;
            color: var(--dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }
        .file-drop {
            border: 2px dashed var(--border);
            border-radius: 6px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .file-drop:hover { border-color: var(--accent); }
        .file-drop.over { border-color: var(--accent); background: rgba(232,197,71,0.05); }
        .file-drop input { display: none; }
        .file-drop p { font-size: 13px; color: var(--dim); }
        .file-drop.has-file p { color: var(--accent); }
        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        .range-val {
            text-align: right;
            font-size: 13px;
            color: var(--accent);
            margin-top: 4px;
        }
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        .btn-start {
            background: var(--accent);
            color: #000;
            font-weight: 600;
        }
        .btn-start:hover:not(:disabled) { background: #fff; }
        .btn-start:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-stop {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--dim);
        }
        .btn-stop:hover:not(:disabled) { border-color: var(--accent); color: var(--text); }
        .btn-stop:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .btn-group button {
            margin-bottom: 0;
        }
        .stats {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }
        .stat {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            padding: 5px 0;
        }
        .stat span:first-child { color: var(--dim); }
        .stat span:last-child { color: var(--accent); }
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 12px;
            color: var(--dim);
        }
        footer a { color: var(--accent); text-decoration: none; }
        .error-msg {
            background: rgba(255, 80, 80, 0.1);
            border: 1px solid rgba(255, 80, 80, 0.3);
            color: #ff6b6b;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 15px;
            display: none;
        }
        .error-msg.show { display: block; }
        
        /* Path Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-overlay.show {
            display: flex;
        }
        .modal {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            font-size: 16px;
            font-weight: 500;
            color: var(--accent);
        }
        .modal-close {
            background: none;
            border: none;
            color: var(--dim);
            font-size: 24px;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }
        .modal-close:hover {
            color: var(--text);
        }
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        .path-info {
            font-size: 13px;
            color: var(--dim);
            margin-bottom: 15px;
            line-height: 1.6;
        }
        .path-info strong {
            color: var(--accent);
        }
        .path-content {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.8;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        .modal-footer button {
            width: auto;
            padding: 10px 20px;
            margin: 0;
        }
        .format-select {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .format-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--dim);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .format-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }
        .format-btn.active {
            border-color: var(--accent);
            background: rgba(232, 197, 71, 0.1);
            color: var(--accent);
        }
    </style>
</head>
<body>
    <h1>STRING ART</h1>
    <div class="container">
        <div class="canvas-area">
            <div class="canvases">
                <div class="canvas-box">
                    <canvas id="srcCanvas" width="480" height="480"></canvas>
                    <span>Source</span>
                </div>
                <div class="canvas-box">
                    <canvas id="outCanvas" width="480" height="480"></canvas>
                    <span>String Art</span>
                </div>
            </div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <div class="status" id="status">Upload an image to begin</div>
        </div>
        <div class="controls">
            <div class="error-msg" id="errorMsg"></div>
            <div class="control-group">
                <label>Image</label>
                <div class="file-drop" id="dropZone">
                    <input type="file" id="fileInput" accept="image/*">
                    <p id="fileLabel">Click or drop image here</p>
                </div>
            </div>
            <div class="control-group">
                <label>Number of Pegs</label>
                <input type="range" id="numPegs" min="180" max="360" value="360">
                <div class="range-val" id="numPegsVal">360</div>
            </div>
            <div class="control-group">
                <label>Line Opacity</label>
                <input type="range" id="lineAlpha" min="3" max="30" value="8">
                <div class="range-val" id="lineAlphaVal">8%</div>
            </div>
            <div class="control-group">
                <label>Threshold</label>
                <input type="range" id="threshold" min="500" max="5000" value="2000" step="100">
                <div class="range-val" id="thresholdVal">2000</div>
            </div>
            <div class="control-group">
                <label>Max Lines</label>
                <input type="range" id="maxLines" min="1000" max="10000" value="5000" step="500">
                <div class="range-val" id="maxLinesVal">5000</div>
            </div>
            <button class="btn-start" id="btnStart" disabled>Generate</button>
            <button class="btn-stop" id="btnStop" disabled>Stop</button>
            <div class="btn-group">
                <button class="btn-stop" id="btnDownload" disabled>Download Image</button>
                <button class="btn-stop" id="btnPath" disabled>View Path</button>
            </div>
            <div class="stats">
                <div class="stat"><span>Strings</span><span id="statLines">0</span></div>
                <div class="stat"><span>Iterations</span><span id="statIter">0</span></div>
                <div class="stat"><span>Time</span><span id="statTime">-</span></div>
            </div>
        </div>
    </div>
    <footer>
        <a href="https://en.wikipedia.org/wiki/String_art" target="_blank">Learn about String Art</a>
    </footer>

    <!-- Path Modal -->
    <div class="modal-overlay" id="pathModal">
        <div class="modal">
            <div class="modal-header">
                <h2>String Path (Continuous)</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body">
                <div class="path-info">
                    Total: <strong id="pathTotal">0</strong> strings | 
                    Pegs: <strong id="pathPegs">0</strong><br>
                    Peg <strong>0</strong> is at top (12 o'clock), numbering goes <strong>clockwise</strong>.<br>
                    This is a <strong>continuous path</strong> — wind the string without cutting!
                </div>
                <div class="format-select">
                    <button class="format-btn active" data-format="sequence">Sequence</button>
                    <button class="format-btn" data-format="steps">Steps</button>
                    <button class="format-btn" data-format="csv">CSV</button>
                    <button class="format-btn" data-format="json">JSON</button>
                </div>
                <div class="path-content" id="pathContent"></div>
            </div>
            <div class="modal-footer">
                <button class="btn-stop" id="btnCopyPath">Copy to Clipboard</button>
                <button class="btn-start" id="btnDownloadPath">Download</button>
            </div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * STRING ART GENERATOR - CONTINUOUS PATH VERSION
 * ============================================================================
 * 
 * This version generates a CONTINUOUS PATH that can be used for physical
 * string art recreation. The algorithm always moves from the current peg
 * to the next best peg, creating an unbroken sequence.
 * 
 * ALGORITHM (Continuous Path):
 * ----------------------------
 * 1. Start at peg 0
 * 2. From current peg, find the best unvisited connection
 * 3. Draw that string and move to the new peg
 * 4. Repeat until no good connections remain
 * 
 * This produces output like: 0 → 180 → 45 → 230 → 12 → ...
 * which represents the actual winding order for physical recreation.
 * 
 * ============================================================================
 */

(function() {
    'use strict';
    
    // =========================================================================
    // CONFIGURATION CONSTANTS
    // =========================================================================
    
    const SIZE = 480;
    const RADIUS = 230;
    const CENTER = SIZE / 2;
    
    // =========================================================================
    // DOM ELEMENT CACHE
    // =========================================================================
    
    const elements = {
        srcCanvas: document.getElementById('srcCanvas'),
        outCanvas: document.getElementById('outCanvas'),
        fileInput: document.getElementById('fileInput'),
        dropZone: document.getElementById('dropZone'),
        fileLabel: document.getElementById('fileLabel'),
        numPegsInput: document.getElementById('numPegs'),
        lineAlphaInput: document.getElementById('lineAlpha'),
        thresholdInput: document.getElementById('threshold'),
        maxLinesInput: document.getElementById('maxLines'),
        btnStart: document.getElementById('btnStart'),
        btnStop: document.getElementById('btnStop'),
        btnDownload: document.getElementById('btnDownload'),
        btnPath: document.getElementById('btnPath'),
        progressEl: document.getElementById('progress'),
        statusEl: document.getElementById('status'),
        errorMsg: document.getElementById('errorMsg'),
        statLines: document.getElementById('statLines'),
        statIter: document.getElementById('statIter'),
        statTime: document.getElementById('statTime'),
        numPegsVal: document.getElementById('numPegsVal'),
        lineAlphaVal: document.getElementById('lineAlphaVal'),
        thresholdVal: document.getElementById('thresholdVal'),
        maxLinesVal: document.getElementById('maxLinesVal'),
        // Modal elements
        pathModal: document.getElementById('pathModal'),
        modalClose: document.getElementById('modalClose'),
        pathTotal: document.getElementById('pathTotal'),
        pathPegs: document.getElementById('pathPegs'),
        pathContent: document.getElementById('pathContent'),
        btnCopyPath: document.getElementById('btnCopyPath'),
        btnDownloadPath: document.getElementById('btnDownloadPath')
    };
    
    const srcCtx = elements.srcCanvas.getContext('2d', { willReadFrequently: true });
    const outCtx = elements.outCanvas.getContext('2d');
    
    // =========================================================================
    // APPLICATION STATE
    // =========================================================================
    
    let state = {
        sourceImg: null,
        targetData: null,
        running: false,
        stopFlag: false,
        fileName: '',
        // Path tracking - now a simple array of peg numbers
        stringPath: [],      // [0, 180, 45, 230, 12, ...] continuous sequence
        numPegsUsed: 0,
        currentFormat: 'sequence'
    };
    
    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================
    
    function showError(msg) {
        elements.errorMsg.textContent = msg;
        elements.errorMsg.classList.add('show');
        setTimeout(() => elements.errorMsg.classList.remove('show'), 5000);
    }
    
    function setStatus(text, active = false) {
        elements.statusEl.textContent = text;
        elements.statusEl.className = 'status' + (active ? ' active' : '');
    }
    
    function formatTime(ms) {
        if (ms < 1000) return ms + 'ms';
        return (ms / 1000).toFixed(1) + 's';
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // =========================================================================
    // PATH FORMATTING FUNCTIONS
    // =========================================================================
    
    /**
     * Format as continuous sequence with arrows.
     * This is the most useful format for physical recreation.
     * 
     * Example: 0 → 180 → 45 → 230 → 12 → ...
     */
    function formatAsSequence() {
        if (state.stringPath.length === 0) return 'No path generated yet.';
        
        let result = '';
        for (let i = 0; i < state.stringPath.length; i++) {
            result += state.stringPath[i];
            if (i < state.stringPath.length - 1) {
                result += ' → ';
            }
            // Line break every 10 pegs for readability
            if ((i + 1) % 10 === 0 && i < state.stringPath.length - 1) {
                result += '\n';
            }
        }
        
        return result;
    }
    
    /**
     * Format as numbered steps.
     * Each line shows: step number, from peg, to peg
     * 
     * Example:
     *    1: 0 → 180
     *    2: 180 → 45
     *    3: 45 → 230
     */
    function formatAsSteps() {
        if (state.stringPath.length < 2) return 'No path generated yet.';
        
        const lines = [];
        for (let i = 0; i < state.stringPath.length - 1; i++) {
            const stepNum = (i + 1).toString().padStart(4);
            lines.push(`${stepNum}: ${state.stringPath[i]} → ${state.stringPath[i + 1]}`);
        }
        
        return lines.join('\n');
    }
    
    /**
     * Format as CSV for spreadsheet import.
     * 
     * Example:
     * step,from,to
     * 1,0,180
     * 2,180,45
     */
    function formatAsCSV() {
        if (state.stringPath.length < 2) return 'No path generated yet.';
        
        let csv = 'step,from,to\n';
        for (let i = 0; i < state.stringPath.length - 1; i++) {
            csv += `${i + 1},${state.stringPath[i]},${state.stringPath[i + 1]}\n`;
        }
        
        return csv.trim();
    }
    
    /**
     * Format as JSON for programmatic use.
     */
    function formatAsJSON() {
        if (state.stringPath.length === 0) return '{}';
        
        const steps = [];
        for (let i = 0; i < state.stringPath.length - 1; i++) {
            steps.push({
                step: i + 1,
                from: state.stringPath[i],
                to: state.stringPath[i + 1]
            });
        }
        
        const data = {
            metadata: {
                totalStrings: state.stringPath.length - 1,
                totalPegs: state.numPegsUsed,
                generatedAt: new Date().toISOString(),
                description: "Continuous path for string art. Peg 0 is at 12 o'clock, numbering clockwise."
            },
            sequence: state.stringPath,
            steps: steps
        };
        
        return JSON.stringify(data, null, 2);
    }
    
    function getFormattedPath() {
        switch (state.currentFormat) {
            case 'sequence': return formatAsSequence();
            case 'steps': return formatAsSteps();
            case 'csv': return formatAsCSV();
            case 'json': return formatAsJSON();
            default: return formatAsSequence();
        }
    }
    
    function getFileExtension() {
        switch (state.currentFormat) {
            case 'csv': return 'csv';
            case 'json': return 'json';
            default: return 'txt';
        }
    }
    
    // =========================================================================
    // MODAL FUNCTIONS
    // =========================================================================
    
    function showPathModal() {
        elements.pathTotal.textContent = Math.max(0, state.stringPath.length - 1);
        elements.pathPegs.textContent = state.numPegsUsed;
        elements.pathContent.textContent = getFormattedPath();
        elements.pathModal.classList.add('show');
    }
    
    function hidePathModal() {
        elements.pathModal.classList.remove('show');
    }
    
    function updatePathDisplay() {
        elements.pathContent.textContent = getFormattedPath();
    }
    
    async function copyPathToClipboard() {
        try {
            await navigator.clipboard.writeText(getFormattedPath());
            elements.btnCopyPath.textContent = 'Copied!';
            setTimeout(() => {
                elements.btnCopyPath.textContent = 'Copy to Clipboard';
            }, 2000);
        } catch (err) {
            showError('Failed to copy to clipboard');
        }
    }
    
    function downloadPath() {
        const content = getFormattedPath();
        const ext = getFileExtension();
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
        const filename = state.fileName 
            ? `string-art-path-${state.fileName}-${timestamp}.${ext}`
            : `string-art-path-${timestamp}.${ext}`;
        
        const blob = new Blob([content], { type: 'text/plain' });
        const link = document.createElement('a');
        link.download = filename;
        link.href = URL.createObjectURL(blob);
        link.click();
        URL.revokeObjectURL(link.href);
    }
    
    // =========================================================================
    // PRE-COMPUTATION FUNCTIONS
    // =========================================================================
    
    /**
     * Pre-compute peg positions around the circle.
     * Peg 0 is at top (12 o'clock), numbering goes clockwise.
     */
    function precomputePegPositions(numPegs) {
        const positions = new Float32Array(numPegs * 2);
        
        for (let i = 0; i < numPegs; i++) {
            // Start from top (-π/2) and go clockwise
            const angle = (i / numPegs) * Math.PI * 2 - Math.PI / 2;
            positions[i * 2] = CENTER + RADIUS * Math.cos(angle);
            positions[i * 2 + 1] = CENTER + RADIUS * Math.sin(angle);
        }
        
        return positions;
    }
    
    /**
     * Pre-compute pixels for all possible line connections.
     * Returns a Map where key is "smallerPeg,largerPeg" and value is pixel array.
     */
    function precomputeAllLinePixels(numPegs, positions, minDist) {
        const lineCache = new Map();
        
        for (let i = 0; i < numPegs; i++) {
            const x0 = Math.round(positions[i * 2]);
            const y0 = Math.round(positions[i * 2 + 1]);
            
            for (let j = i + 1; j < numPegs; j++) {
                // Calculate circular distance
                const dist = Math.min(j - i, numPegs - (j - i));
                if (dist < minDist) continue;
                
                const x1 = Math.round(positions[j * 2]);
                const y1 = Math.round(positions[j * 2 + 1]);
                
                const pixels = bresenhamLine(x0, y0, x1, y1);
                
                // Use string key for clarity: "smaller,larger"
                const key = `${i},${j}`;
                lineCache.set(key, pixels);
            }
        }
        
        return lineCache;
    }
    
    /**
     * Get cache key for a connection (always smaller,larger order).
     */
    function getConnectionKey(peg1, peg2) {
        return peg1 < peg2 ? `${peg1},${peg2}` : `${peg2},${peg1}`;
    }
    
    /**
     * Bresenham's line algorithm - returns array of pixel indices.
     */
    function bresenhamLine(x0, y0, x1, y1) {
        const pixels = [];
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;
        
        while (true) {
            if (x0 >= 0 && x0 < SIZE && y0 >= 0 && y0 < SIZE) {
                pixels.push(y0 * SIZE + x0);
            }
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
        
        return new Uint32Array(pixels);
    }
    
    // =========================================================================
    // IMAGE LOADING AND PROCESSING
    // =========================================================================
    
    function loadImage(file) {
        if (!file.type.startsWith('image/')) {
            showError('Please upload a valid image file');
            return;
        }
        
        if (file.size > 10 * 1024 * 1024) {
            showError('Image file too large. Please choose an image under 10MB');
            return;
        }
        
        const reader = new FileReader();
        
        reader.onerror = function() {
            showError('Error reading file');
        };
        
        reader.onload = function(e) {
            const img = new Image();
            
            img.onerror = function() {
                showError('Unable to load image. Format may not be supported');
            };
            
            img.onload = function() {
                state.sourceImg = img;
                state.fileName = file.name.replace(/\.[^/.]+$/, '');
                prepareSource();
                elements.btnStart.disabled = false;
                elements.dropZone.classList.add('has-file');
                elements.fileLabel.textContent = file.name;
                setStatus('Image loaded. Click Generate to start.');
            };
            
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
    }
    
    function prepareSource() {
        srcCtx.fillStyle = '#fff';
        srcCtx.fillRect(0, 0, SIZE, SIZE);
        
        const minDim = Math.min(state.sourceImg.width, state.sourceImg.height);
        const sx = (state.sourceImg.width - minDim) / 2;
        const sy = (state.sourceImg.height - minDim) / 2;
        
        srcCtx.save();
        srcCtx.beginPath();
        srcCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        srcCtx.clip();
        srcCtx.drawImage(
            state.sourceImg,
            sx, sy, minDim, minDim,
            CENTER - RADIUS, CENTER - RADIUS, RADIUS * 2, RADIUS * 2
        );
        srcCtx.restore();
        
        const imgData = srcCtx.getImageData(0, 0, SIZE, SIZE);
        const d = imgData.data;
        const len = d.length;
        
        for (let i = 0; i < len; i += 4) {
            const gray = Math.round(0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2]);
            d[i] = d[i + 1] = d[i + 2] = gray;
        }
        srcCtx.putImageData(imgData, 0, 0);
        
        srcCtx.strokeStyle = '#888';
        srcCtx.lineWidth = 1;
        srcCtx.beginPath();
        srcCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        srcCtx.stroke();
        
        state.targetData = new Uint8Array(SIZE * SIZE);
        for (let i = 0; i < SIZE * SIZE; i++) {
            state.targetData[i] = imgData.data[i * 4];
        }
    }
    
    // =========================================================================
    // MAIN STRING ART GENERATION - CONTINUOUS PATH ALGORITHM
    // =========================================================================
    
    /**
     * Generate string art using a CONTINUOUS PATH algorithm.
     * 
     * Unlike the original algorithm that finds the globally best line each iteration,
     * this version always moves from the CURRENT peg to the next best peg.
     * This produces a path that can actually be wound with a single thread.
     */
    async function startGeneration() {
        if (state.running || !state.sourceImg) return;
        
        state.running = true;
        state.stopFlag = false;
        
        // Clear previous path
        state.stringPath = [];
        
        elements.btnStart.disabled = true;
        elements.btnStop.disabled = false;
        elements.btnDownload.disabled = true;
        elements.btnPath.disabled = true;
        
        // Get parameters
        const numPegs = parseInt(elements.numPegsInput.value);
        const lineAlpha = parseInt(elements.lineAlphaInput.value) / 100;
        const threshold = parseInt(elements.thresholdInput.value);
        const maxLines = parseInt(elements.maxLinesInput.value);
        const darkness = Math.round(lineAlpha * 255);
        const minDist = Math.floor(numPegs * 0.1);
        
        state.numPegsUsed = numPegs;
        
        // Pre-computation phase
        setStatus('Pre-computing peg positions...', true);
        await sleep(10);
        
        const pegPositions = precomputePegPositions(numPegs);
        
        setStatus('Pre-computing line paths...', true);
        await sleep(10);
        
        const linePixelsCache = precomputeAllLinePixels(numPegs, pegPositions, minDist);
        
        // Initialize output canvas
        outCtx.fillStyle = '#fff';
        outCtx.fillRect(0, 0, SIZE, SIZE);
        outCtx.strokeStyle = '#ddd';
        outCtx.lineWidth = 1;
        outCtx.beginPath();
        outCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        outCtx.stroke();
        
        // Initialize brightness tracking
        const currentData = new Uint8Array(SIZE * SIZE);
        currentData.fill(255);
        
        // Track used connections (each connection can only be used once)
        const usedConnections = new Set();
        
        // Statistics
        let lineCount = 0;
        const startTime = performance.now();
        
        // =====================================================================
        // CONTINUOUS PATH ALGORITHM
        // =====================================================================
        
        // Start at peg 0
        let currentPeg = 0;
        state.stringPath.push(currentPeg);
        
        setStatus('Generating continuous path...', true);
        
        // Keep finding the next best peg from current position
        while (!state.stopFlag && lineCount < maxLines) {
            let bestNextPeg = -1;
            let maxDiff = 0;
            let bestPixels = null;
            
            // Try all possible next pegs from current position
            for (let tryPeg = 0; tryPeg < numPegs; tryPeg++) {
                if (tryPeg === currentPeg) continue;
                
                // Check minimum distance
                const dist = Math.min(
                    Math.abs(tryPeg - currentPeg),
                    numPegs - Math.abs(tryPeg - currentPeg)
                );
                if (dist < minDist) continue;
                
                // Check if this connection was already used
                const connectionKey = getConnectionKey(currentPeg, tryPeg);
                if (usedConnections.has(connectionKey)) continue;
                
                // Get cached pixels for this line
                const pixels = linePixelsCache.get(connectionKey);
                if (!pixels) continue;
                
                // Calculate brightness difference
                // Positive diff = current brighter than target = needs darkening
                let diff = 0;
                for (let j = 0; j < pixels.length; j++) {
                    const idx = pixels[j];
                    diff += currentData[idx] - state.targetData[idx];
                }
                
                // Track the best option
                if (diff > maxDiff) {
                    maxDiff = diff;
                    bestNextPeg = tryPeg;
                    bestPixels = pixels;
                }
            }
            
            // If no good connection found, we're done
            if (maxDiff <= threshold || bestNextPeg === -1) {
                break;
            }
            
            // Draw the string
            for (let j = 0; j < bestPixels.length; j++) {
                const idx = bestPixels[j];
                currentData[idx] = Math.max(0, currentData[idx] - darkness);
            }
            
            // Draw on canvas
            outCtx.strokeStyle = `rgba(0,0,0,${lineAlpha})`;
            outCtx.lineWidth = 1;
            outCtx.beginPath();
            outCtx.moveTo(
                pegPositions[currentPeg * 2],
                pegPositions[currentPeg * 2 + 1]
            );
            outCtx.lineTo(
                pegPositions[bestNextPeg * 2],
                pegPositions[bestNextPeg * 2 + 1]
            );
            outCtx.stroke();
            
            // Mark connection as used
            const connectionKey = getConnectionKey(currentPeg, bestNextPeg);
            usedConnections.add(connectionKey);
            
            // Move to next peg
            currentPeg = bestNextPeg;
            state.stringPath.push(currentPeg);
            
            lineCount++;
            
            // Update UI periodically
            if (lineCount % 50 === 0) {
                const progress = Math.min(100, (lineCount / maxLines) * 100);
                elements.progressEl.style.width = progress + '%';
                elements.statLines.textContent = lineCount;
                elements.statIter.textContent = '-';
                elements.statTime.textContent = formatTime(performance.now() - startTime);
                await sleep(0);
            }
        }
        
        // =====================================================================
        // COMPLETION
        // =====================================================================
        
        const elapsed = performance.now() - startTime;
        
        elements.progressEl.style.width = '100%';
        elements.statLines.textContent = lineCount;
        elements.statIter.textContent = '-';
        elements.statTime.textContent = formatTime(elapsed);
        
        state.running = false;
        elements.btnStart.disabled = false;
        elements.btnStop.disabled = true;
        elements.btnDownload.disabled = false;
        elements.btnPath.disabled = false;
        
        if (state.stopFlag) {
            setStatus(`Stopped: ${lineCount} strings`);
        } else if (lineCount >= maxLines) {
            setStatus(`Max lines reached: ${lineCount} strings`);
        } else {
            setStatus(`Done! ${lineCount} strings (continuous path)`);
        }
    }
    
    // =========================================================================
    // DOWNLOAD FUNCTIONALITY
    // =========================================================================
    
    function downloadResult() {
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
        const filename = state.fileName 
            ? `string-art-${state.fileName}-${timestamp}.png`
            : `string-art-${timestamp}.png`;
        
        const link = document.createElement('a');
        link.download = filename;
        link.href = elements.outCanvas.toDataURL('image/png');
        link.click();
    }
    
    // =========================================================================
    // EVENT LISTENERS
    // =========================================================================
    
    // File input
    elements.dropZone.addEventListener('click', () => elements.fileInput.click());
    elements.fileInput.addEventListener('change', (e) => {
        if (e.target.files[0]) loadImage(e.target.files[0]);
    });
    elements.dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        elements.dropZone.classList.add('over');
    });
    elements.dropZone.addEventListener('dragleave', () => {
        elements.dropZone.classList.remove('over');
    });
    elements.dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        elements.dropZone.classList.remove('over');
        if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
    });
    
    // Sliders
    elements.numPegsInput.addEventListener('input', function() {
        elements.numPegsVal.textContent = this.value;
    });
    elements.lineAlphaInput.addEventListener('input', function() {
        elements.lineAlphaVal.textContent = this.value + '%';
    });
    elements.thresholdInput.addEventListener('input', function() {
        elements.thresholdVal.textContent = this.value;
    });
    elements.maxLinesInput.addEventListener('input', function() {
        elements.maxLinesVal.textContent = this.value;
    });
    
    // Buttons
    elements.btnStart.addEventListener('click', () => {
        if (!state.running) startGeneration();
    });
    elements.btnStop.addEventListener('click', () => {
        state.stopFlag = true;
    });
    elements.btnDownload.addEventListener('click', downloadResult);
    elements.btnPath.addEventListener('click', showPathModal);
    
    // Modal
    elements.modalClose.addEventListener('click', hidePathModal);
    elements.pathModal.addEventListener('click', (e) => {
        if (e.target === elements.pathModal) hidePathModal();
    });
    elements.btnCopyPath.addEventListener('click', copyPathToClipboard);
    elements.btnDownloadPath.addEventListener('click', downloadPath);
    
    // Format buttons
    document.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            state.currentFormat = btn.dataset.format;
            updatePathDisplay();
        });
    });
    
    // Keyboard
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && elements.pathModal.classList.contains('show')) {
            hidePathModal();
        }
    });
    
    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    
    function initCanvases() {
        srcCtx.fillStyle = '#222';
        srcCtx.fillRect(0, 0, SIZE, SIZE);
        srcCtx.strokeStyle = '#444';
        srcCtx.beginPath();
        srcCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        srcCtx.stroke();
        srcCtx.fillStyle = '#666';
        srcCtx.font = '14px sans-serif';
        srcCtx.textAlign = 'center';
        srcCtx.fillText('Upload image', CENTER, CENTER);
        
        outCtx.fillStyle = '#f5f5f5';
        outCtx.fillRect(0, 0, SIZE, SIZE);
        outCtx.strokeStyle = '#ddd';
        outCtx.beginPath();
        outCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        outCtx.stroke();
        outCtx.fillStyle = '#aaa';
        outCtx.font = '14px sans-serif';
        outCtx.textAlign = 'center';
        outCtx.fillText('Result', CENTER, CENTER);
    }
    
    initCanvases();
    
})();
</script>
</body>
</html>
