<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Art Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0b;
            --card: #141416;
            --accent: #e8c547;
            --text: #f5f5f4;
            --dim: #8a8a8a;
            --border: #2a2a2d;
        }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        h1 {
            text-align: center;
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-bottom: 30px;
            color: var(--accent);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 30px;
        }
        @media (max-width: 800px) {
            .container { grid-template-columns: 1fr; }
        }
        .canvas-area {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
        }
        .canvases {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .canvas-box {
            position: relative;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
        }
        .canvas-box canvas {
            display: block;
            width: 100%;
            height: auto;
        }
        .canvas-box span {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 11px;
            color: var(--dim);
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 3px;
        }
        .progress {
            margin-top: 15px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.1s;
        }
        .status {
            margin-top: 10px;
            font-size: 13px;
            color: var(--dim);
        }
        .status.active { color: var(--accent); }
        .controls {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-size: 11px;
            color: var(--dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
        }
        .file-drop {
            border: 2px dashed var(--border);
            border-radius: 6px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .file-drop:hover { border-color: var(--accent); }
        .file-drop.over { border-color: var(--accent); background: rgba(232,197,71,0.05); }
        .file-drop input { display: none; }
        .file-drop p { font-size: 13px; color: var(--dim); }
        .file-drop.has-file p { color: var(--accent); }
        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }
        .range-val {
            text-align: right;
            font-size: 13px;
            color: var(--accent);
            margin-top: 4px;
        }
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
        }
        .btn-start {
            background: var(--accent);
            color: #000;
            font-weight: 600;
        }
        .btn-start:hover:not(:disabled) { background: #fff; }
        .btn-start:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-stop {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--dim);
        }
        .btn-stop:hover:not(:disabled) { border-color: var(--accent); color: var(--text); }
        .btn-stop:disabled { opacity: 0.4; cursor: not-allowed; }
        .stats {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }
        .stat {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            padding: 5px 0;
        }
        .stat span:first-child { color: var(--dim); }
        .stat span:last-child { color: var(--accent); }
        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 12px;
            color: var(--dim);
        }
        footer a { color: var(--accent); text-decoration: none; }
        .error-msg {
            background: rgba(255, 80, 80, 0.1);
            border: 1px solid rgba(255, 80, 80, 0.3);
            color: #ff6b6b;
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 15px;
            display: none;
        }
        .error-msg.show { display: block; }
    </style>
</head>
<body>
    <h1>STRING ART</h1>
    <div class="container">
        <div class="canvas-area">
            <div class="canvases">
                <div class="canvas-box">
                    <canvas id="srcCanvas" width="480" height="480"></canvas>
                    <span>Source</span>
                </div>
                <div class="canvas-box">
                    <canvas id="outCanvas" width="480" height="480"></canvas>
                    <span>String Art</span>
                </div>
            </div>
            <div class="progress"><div class="progress-fill" id="progress"></div></div>
            <div class="status" id="status">Upload an image to begin</div>
        </div>
        <div class="controls">
            <div class="error-msg" id="errorMsg"></div>
            <div class="control-group">
                <label>Image</label>
                <div class="file-drop" id="dropZone">
                    <input type="file" id="fileInput" accept="image/*">
                    <p id="fileLabel">Click or drop image here</p>
                </div>
            </div>
            <div class="control-group">
                <label>Number of Pegs</label>
                <input type="range" id="numPegs" min="180" max="360" value="360">
                <div class="range-val" id="numPegsVal">360</div>
            </div>
            <div class="control-group">
                <label>Line Opacity</label>
                <input type="range" id="lineAlpha" min="3" max="30" value="8">
                <div class="range-val" id="lineAlphaVal">8%</div>
            </div>
            <div class="control-group">
                <label>Threshold</label>
                <input type="range" id="threshold" min="500" max="5000" value="2000" step="100">
                <div class="range-val" id="thresholdVal">2000</div>
            </div>
            <div class="control-group">
                <label>Max Lines</label>
                <input type="range" id="maxLines" min="1000" max="10000" value="5000" step="500">
                <div class="range-val" id="maxLinesVal">5000</div>
            </div>
            <button class="btn-start" id="btnStart" disabled>Generate</button>
            <button class="btn-stop" id="btnStop" disabled>Stop</button>
            <button class="btn-stop" id="btnDownload" disabled>Download</button>
            <div class="stats">
                <div class="stat"><span>Strings</span><span id="statLines">0</span></div>
                <div class="stat"><span>Iterations</span><span id="statIter">0</span></div>
                <div class="stat"><span>Time</span><span id="statTime">-</span></div>
            </div>
        </div>
    </div>
    <footer>
        <a href="https://en.wikipedia.org/wiki/String_art" target="_blank">Learn about String Art</a>
    </footer>

<script>
/**
 * ============================================================================
 * STRING ART GENERATOR
 * ============================================================================
 * 
 * This application converts any image into a "string art" representation.
 * String art is a technique where an image is recreated by wrapping thread
 * around pegs arranged in a circle, creating the illusion of the original
 * image through the density of overlapping lines.
 * 
 * ALGORITHM OVERVIEW:
 * -------------------
 * The algorithm uses a greedy approach to iteratively find the best string
 * to add that will make the current output most closely match the target:
 * 
 * 1. Place N pegs evenly around a circle
 * 2. Start with a white canvas
 * 3. For each peg, find the connection to another peg that would reduce
 *    the most "error" (difference between current and target brightness)
 * 4. Draw that string (semi-transparent black line)
 * 5. Repeat until no significant improvement can be made
 * 
 * KEY OPTIMIZATIONS IN THIS VERSION:
 * ----------------------------------
 * 1. Pre-computation of all peg positions using Float32Array
 * 2. Pre-computation of all possible line pixels using Bresenham's algorithm
 * 3. Using Set with numeric keys instead of string concatenation for tracking
 * 4. Using Typed Arrays (Uint8Array, Uint32Array) for better memory access
 * 5. Async/await pattern for non-blocking UI updates
 * 
 * ============================================================================
 */

(function() {
    'use strict';
    
    // =========================================================================
    // CONFIGURATION CONSTANTS
    // =========================================================================
    
    /**
     * SIZE: The dimensions of both canvases in pixels (square).
     * Larger values produce higher quality but slower generation.
     */
    const SIZE = 480;
    
    /**
     * RADIUS: The radius of the circle where pegs are placed.
     * Should be slightly less than SIZE/2 to leave a margin.
     */
    const RADIUS = 230;
    
    /**
     * CENTER: The center point of the canvas.
     * All peg positions are calculated relative to this point.
     */
    const CENTER = SIZE / 2;
    
    // =========================================================================
    // DOM ELEMENT CACHE
    // =========================================================================
    
    /**
     * Caching DOM elements improves performance by avoiding repeated
     * document.getElementById() calls during the generation loop.
     */
    const elements = {
        // Canvas elements
        srcCanvas: document.getElementById('srcCanvas'),
        outCanvas: document.getElementById('outCanvas'),
        
        // File input elements
        fileInput: document.getElementById('fileInput'),
        dropZone: document.getElementById('dropZone'),
        fileLabel: document.getElementById('fileLabel'),
        
        // Control inputs
        numPegsInput: document.getElementById('numPegs'),
        lineAlphaInput: document.getElementById('lineAlpha'),
        thresholdInput: document.getElementById('threshold'),
        maxLinesInput: document.getElementById('maxLines'),
        
        // Buttons
        btnStart: document.getElementById('btnStart'),
        btnStop: document.getElementById('btnStop'),
        btnDownload: document.getElementById('btnDownload'),
        
        // Display elements
        progressEl: document.getElementById('progress'),
        statusEl: document.getElementById('status'),
        errorMsg: document.getElementById('errorMsg'),
        
        // Statistics display
        statLines: document.getElementById('statLines'),
        statIter: document.getElementById('statIter'),
        statTime: document.getElementById('statTime'),
        
        // Value labels for sliders
        numPegsVal: document.getElementById('numPegsVal'),
        lineAlphaVal: document.getElementById('lineAlphaVal'),
        thresholdVal: document.getElementById('thresholdVal'),
        maxLinesVal: document.getElementById('maxLinesVal')
    };
    
    /**
     * Get 2D rendering contexts for both canvases.
     * The 'willReadFrequently' hint optimizes for getImageData() calls.
     */
    const srcCtx = elements.srcCanvas.getContext('2d', { willReadFrequently: true });
    const outCtx = elements.outCanvas.getContext('2d');
    
    // =========================================================================
    // APPLICATION STATE
    // =========================================================================
    
    /**
     * Centralized state object for better organization and debugging.
     * 
     * @property {Image|null} sourceImg - The loaded source image
     * @property {Uint8Array|null} targetData - Grayscale pixel values of target
     * @property {boolean} running - Whether generation is in progress
     * @property {boolean} stopFlag - Signal to stop generation early
     * @property {string} fileName - Original filename for download naming
     */
    let state = {
        sourceImg: null,
        targetData: null,
        running: false,
        stopFlag: false,
        fileName: ''
    };
    
    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================
    
    /**
     * Display an error message to the user.
     * The message auto-hides after 5 seconds.
     * 
     * @param {string} msg - The error message to display
     */
    function showError(msg) {
        elements.errorMsg.textContent = msg;
        elements.errorMsg.classList.add('show');
        setTimeout(() => elements.errorMsg.classList.remove('show'), 5000);
    }
    
    /**
     * Update the status text below the progress bar.
     * 
     * @param {string} text - The status message
     * @param {boolean} active - If true, use accent color (indicates processing)
     */
    function setStatus(text, active = false) {
        elements.statusEl.textContent = text;
        elements.statusEl.className = 'status' + (active ? ' active' : '');
    }
    
    /**
     * Format milliseconds into a human-readable time string.
     * 
     * @param {number} ms - Time in milliseconds
     * @returns {string} Formatted time (e.g., "1.5s" or "234ms")
     */
    function formatTime(ms) {
        if (ms < 1000) return ms + 'ms';
        return (ms / 1000).toFixed(1) + 's';
    }
    
    /**
     * Create a promise that resolves after a specified delay.
     * Used to yield control back to the browser for UI updates.
     * 
     * @param {number} ms - Delay in milliseconds (0 for next event loop)
     * @returns {Promise} Resolves after the delay
     */
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // =========================================================================
    // PRE-COMPUTATION FUNCTIONS
    // =========================================================================
    
    /**
     * Pre-compute the (x, y) positions of all pegs around the circle.
     * 
     * This optimization stores all peg positions in a Float32Array,
     * eliminating the need to recalculate trigonometric functions
     * during the main generation loop.
     * 
     * Memory layout: [x0, y0, x1, y1, x2, y2, ...]
     * Access pattern: positions[i * 2] = x, positions[i * 2 + 1] = y
     * 
     * @param {number} numPegs - Total number of pegs around the circle
     * @returns {Float32Array} Array of alternating x, y coordinates
     */
    function precomputePegPositions(numPegs) {
        const positions = new Float32Array(numPegs * 2);
        
        for (let i = 0; i < numPegs; i++) {
            // Calculate angle for this peg
            // Starting from -π/2 (top of circle) and going clockwise
            const angle = (i / numPegs) * Math.PI * 2 - Math.PI / 2;
            
            // Convert polar to Cartesian coordinates
            positions[i * 2] = CENTER + RADIUS * Math.cos(angle);
            positions[i * 2 + 1] = CENTER + RADIUS * Math.sin(angle);
        }
        
        return positions;
    }
    
    /**
     * Pre-compute pixel indices for all valid string connections.
     * 
     * This is the KEY OPTIMIZATION that dramatically improves performance.
     * Instead of recalculating which pixels a line passes through on every
     * iteration, we compute this once at startup and cache the results.
     * 
     * For 360 pegs with minDist=36, this creates ~60,000 cached lines.
     * Each line stores the indices of pixels it passes through.
     * 
     * @param {number} numPegs - Total number of pegs
     * @param {Float32Array} positions - Pre-computed peg positions
     * @param {number} minDist - Minimum distance between pegs (in peg indices)
     * @returns {Map<number, Uint32Array>} Map from connection key to pixel indices
     */
    function precomputeAllLinePixels(numPegs, positions, minDist) {
        const lineCache = new Map();
        
        // Iterate through all unique pairs of pegs
        for (let i = 0; i < numPegs; i++) {
            // Round positions to integers for pixel calculations
            const x0 = Math.round(positions[i * 2]);
            const y0 = Math.round(positions[i * 2 + 1]);
            
            // Only compute j > i to avoid duplicates (line i→j same as j→i)
            for (let j = i + 1; j < numPegs; j++) {
                // Calculate circular distance between pegs
                // (accounts for wrap-around, e.g., peg 0 is close to peg 359)
                const dist = Math.min(j - i, numPegs - (j - i));
                
                // Skip connections that are too short
                // Short strings don't contribute much visually and waste computation
                if (dist < minDist) continue;
                
                const x1 = Math.round(positions[j * 2]);
                const y1 = Math.round(positions[j * 2 + 1]);
                
                // Compute pixels along this line using Bresenham's algorithm
                const pixels = bresenhamLine(x0, y0, x1, y1);
                
                // Store with a unique numeric key
                // Key formula: i * numPegs + j guarantees uniqueness for i < j
                const key = i * numPegs + j;
                lineCache.set(key, pixels);
            }
        }
        
        return lineCache;
    }
    
    /**
     * Bresenham's Line Algorithm - Compute all pixels along a line.
     * 
     * This is a classic computer graphics algorithm that determines which
     * pixels should be lit to approximate a straight line between two points.
     * It uses only integer arithmetic, making it very efficient.
     * 
     * The algorithm works by tracking an "error" term that accumulates
     * as we step along the primary axis, and stepping along the secondary
     * axis whenever the error exceeds a threshold.
     * 
     * @param {number} x0 - Starting x coordinate
     * @param {number} y0 - Starting y coordinate
     * @param {number} x1 - Ending x coordinate
     * @param {number} y1 - Ending y coordinate
     * @returns {Uint32Array} Array of pixel indices (y * SIZE + x)
     */
    function bresenhamLine(x0, y0, x1, y1) {
        const pixels = [];
        
        // Calculate the absolute differences
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        
        // Determine step direction for each axis
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        
        // Initialize error term
        // Positive err means we're closer to stepping in x
        // Negative err means we're closer to stepping in y
        let err = dx - dy;
        
        // Trace the line until we reach the endpoint
        while (true) {
            // Only include pixels within canvas bounds
            if (x0 >= 0 && x0 < SIZE && y0 >= 0 && y0 < SIZE) {
                // Convert 2D coordinate to 1D array index
                pixels.push(y0 * SIZE + x0);
            }
            
            // Check if we've reached the endpoint
            if (x0 === x1 && y0 === y1) break;
            
            // Double the error to avoid floating point
            const e2 = 2 * err;
            
            // Step in x direction if appropriate
            if (e2 > -dy) {
                err -= dy;
                x0 += sx;
            }
            
            // Step in y direction if appropriate
            if (e2 < dx) {
                err += dx;
                y0 += sy;
            }
        }
        
        // Return as Uint32Array for better memory efficiency and access speed
        return new Uint32Array(pixels);
    }
    
    // =========================================================================
    // IMAGE LOADING AND PROCESSING
    // =========================================================================
    
    /**
     * Load and validate an image file selected by the user.
     * 
     * This function performs several validation checks:
     * 1. Verifies the file is an image type
     * 2. Checks file size is reasonable (< 10MB)
     * 3. Handles loading errors gracefully
     * 
     * @param {File} file - The file object from file input or drag-drop
     */
    function loadImage(file) {
        // Validate file type using MIME type
        if (!file.type.startsWith('image/')) {
            showError('Please upload a valid image file');
            return;
        }
        
        // Validate file size (10MB limit prevents memory issues)
        if (file.size > 10 * 1024 * 1024) {
            showError('Image file too large. Please choose an image under 10MB');
            return;
        }
        
        // Use FileReader to load the image data
        const reader = new FileReader();
        
        // Handle file reading errors
        reader.onerror = function() {
            showError('Error reading file');
        };
        
        // Process the loaded file data
        reader.onload = function(e) {
            const img = new Image();
            
            // Handle image decoding errors
            img.onerror = function() {
                showError('Unable to load image. Format may not be supported');
            };
            
            // Image loaded successfully
            img.onload = function() {
                // Store image in state
                state.sourceImg = img;
                
                // Extract filename without extension for later download naming
                state.fileName = file.name.replace(/\.[^/.]+$/, '');
                
                // Process and display the source image
                prepareSource();
                
                // Enable the generate button
                elements.btnStart.disabled = false;
                
                // Update UI to show file is loaded
                elements.dropZone.classList.add('has-file');
                elements.fileLabel.textContent = file.name;
                setStatus('Image loaded. Click Generate to start.');
            };
            
            // Start loading the image from the data URL
            img.src = e.target.result;
        };
        
        // Read the file as a data URL (base64 encoded)
        reader.readAsDataURL(file);
    }
    
    /**
     * Process the source image for string art generation.
     * 
     * This function:
     * 1. Crops the image to a square (center crop)
     * 2. Clips it to a circle
     * 3. Converts it to grayscale
     * 4. Stores the grayscale values for comparison during generation
     * 
     * The grayscale conversion uses the standard luminance formula:
     * Y = 0.299*R + 0.587*G + 0.114*B
     * This matches human perception (we're most sensitive to green).
     */
    function prepareSource() {
        // Clear canvas with white background
        srcCtx.fillStyle = '#fff';
        srcCtx.fillRect(0, 0, SIZE, SIZE);
        
        // Calculate center crop dimensions
        // This ensures we use the largest possible square from the center
        const minDim = Math.min(state.sourceImg.width, state.sourceImg.height);
        const sx = (state.sourceImg.width - minDim) / 2;  // Source x offset
        const sy = (state.sourceImg.height - minDim) / 2; // Source y offset
        
        // Apply circular clipping mask
        srcCtx.save();
        srcCtx.beginPath();
        srcCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        srcCtx.clip();
        
        // Draw the image, scaling to fit the circle
        srcCtx.drawImage(
            state.sourceImg,
            sx, sy, minDim, minDim,                              // Source rectangle
            CENTER - RADIUS, CENTER - RADIUS, RADIUS * 2, RADIUS * 2  // Destination rectangle
        );
        srcCtx.restore();
        
        // Get pixel data for grayscale conversion
        const imgData = srcCtx.getImageData(0, 0, SIZE, SIZE);
        const d = imgData.data;  // RGBA array: [r0, g0, b0, a0, r1, g1, b1, a1, ...]
        const len = d.length;
        
        // Convert each pixel to grayscale using luminance formula
        for (let i = 0; i < len; i += 4) {
            const gray = Math.round(
                0.299 * d[i] +      // Red contribution
                0.587 * d[i + 1] +  // Green contribution (highest weight)
                0.114 * d[i + 2]    // Blue contribution
            );
            // Set R, G, B all to the same gray value
            d[i] = d[i + 1] = d[i + 2] = gray;
        }
        
        // Write the grayscale image back to canvas
        srcCtx.putImageData(imgData, 0, 0);
        
        // Draw a border around the circle for visual clarity
        srcCtx.strokeStyle = '#888';
        srcCtx.lineWidth = 1;
        srcCtx.beginPath();
        srcCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        srcCtx.stroke();
        
        // Extract and store grayscale values in a compact array
        // This will be used as the "target" during generation
        state.targetData = new Uint8Array(SIZE * SIZE);
        for (let i = 0; i < SIZE * SIZE; i++) {
            // Every 4th element in RGBA data is the R value (which equals G and B now)
            state.targetData[i] = imgData.data[i * 4];
        }
    }
    
    // =========================================================================
    // MAIN STRING ART GENERATION ALGORITHM
    // =========================================================================
    
    /**
     * Main generation function - orchestrates the string art creation.
     * 
     * ALGORITHM DETAILS:
     * ------------------
     * The algorithm is a greedy optimization that works as follows:
     * 
     * 1. INITIALIZATION:
     *    - Pre-compute all peg positions
     *    - Pre-compute all line pixel paths
     *    - Initialize output canvas to white
     *    - Initialize "current brightness" array to 255 (white)
     * 
     * 2. MAIN LOOP (repeat until no improvement):
     *    For each peg as a starting point:
     *      a. Try all valid connections to other pegs
     *      b. Calculate "brightness difference" for each:
     *         diff = sum of (current[pixel] - target[pixel]) for all pixels on line
     *         Positive diff means area needs darkening
     *      c. Select the connection with maximum diff > threshold
     *      d. Draw that string and update brightness array
     * 
     * 3. TERMINATION:
     *    - No connection exceeds threshold (convergence)
     *    - Max lines reached
     *    - User clicks Stop
     * 
     * WHY THIS WORKS:
     * ---------------
     * Each string darkens a line of pixels. By always choosing the line that
     * most needs darkening, we progressively build up the image. The
     * semi-transparent overlapping lines create gradients and details.
     */
    async function startGeneration() {
        // Prevent double-starts
        if (state.running || !state.sourceImg) return;
        
        // Update state flags
        state.running = true;
        state.stopFlag = false;
        
        // Update button states
        elements.btnStart.disabled = true;
        elements.btnStop.disabled = false;
        elements.btnDownload.disabled = true;
        
        // =====================================================================
        // PARAMETER EXTRACTION
        // =====================================================================
        
        /** Number of pegs around the circle (more pegs = more detail, slower) */
        const numPegs = parseInt(elements.numPegsInput.value);
        
        /** Opacity of each string line (0-1) */
        const lineAlpha = parseInt(elements.lineAlphaInput.value) / 100;
        
        /** Minimum brightness difference required to draw a line */
        const threshold = parseInt(elements.thresholdInput.value);
        
        /** Maximum number of lines to draw (prevents infinite loops) */
        const maxLines = parseInt(elements.maxLinesInput.value);
        
        /** Amount to darken pixels per string (0-255 scale) */
        const darkness = Math.round(lineAlpha * 255);
        
        /** Minimum peg distance (10% of total) to avoid very short strings */
        const minDist = Math.floor(numPegs * 0.1);
        
        // =====================================================================
        // PRE-COMPUTATION PHASE
        // =====================================================================
        
        setStatus('Pre-computing peg positions...', true);
        await sleep(10);  // Yield to allow UI update
        
        const pegPositions = precomputePegPositions(numPegs);
        
        setStatus('Pre-computing line paths (this may take a few seconds)...', true);
        await sleep(10);
        
        // This is the expensive operation - creates cache of all line pixels
        const linePixelsCache = precomputeAllLinePixels(numPegs, pegPositions, minDist);
        
        // =====================================================================
        // OUTPUT CANVAS INITIALIZATION
        // =====================================================================
        
        // Start with white background
        outCtx.fillStyle = '#fff';
        outCtx.fillRect(0, 0, SIZE, SIZE);
        
        // Draw circle border
        outCtx.strokeStyle = '#ddd';
        outCtx.lineWidth = 1;
        outCtx.beginPath();
        outCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        outCtx.stroke();
        
        // =====================================================================
        // BRIGHTNESS TRACKING
        // =====================================================================
        
        /**
         * currentData tracks the simulated brightness of each pixel.
         * Starts at 255 (white) and decreases as strings are drawn.
         * This is separate from the canvas for efficiency - we don't need
         * to read from the canvas, just write to it.
         */
        const currentData = new Uint8Array(SIZE * SIZE);
        currentData.fill(255);  // Initialize all pixels to white
        
        // =====================================================================
        // CONNECTION TRACKING
        // =====================================================================
        
        /**
         * Set to track which peg connections have been used.
         * Using a Set with numeric keys is much faster than string concatenation.
         * Key formula: min(i,j) * numPegs + max(i,j)
         */
        const used = new Set();
        
        // Statistics
        let lineCount = 0;
        let iterCount = 0;
        const startTime = performance.now();
        
        setStatus('Generating...', true);
        
        // =====================================================================
        // MAIN GENERATION LOOP
        // =====================================================================
        
        /**
         * Outer loop: Continue until convergence or limits reached
         * 
         * Each iteration of this loop goes through all pegs and tries to
         * find the best connection for each. An "iteration" is complete
         * when all pegs have been considered.
         */
        mainLoop: while (!state.stopFlag && lineCount < maxLines) {
            let improved = false;  // Track if any string was drawn this iteration
            iterCount++;
            
            // Inner loop: Try each peg as a starting point
            for (let pegIndex = 0; pegIndex < numPegs && !state.stopFlag; pegIndex++) {
                
                // Variables to track best connection found for this peg
                let bestKey = -1;
                let maxDiff = 0;
                let bestPixels = null;
                
                // ---------------------------------------------------------
                // SEARCH: Find the best connection from this peg
                // ---------------------------------------------------------
                
                for (let tryPeg = 0; tryPeg < numPegs; tryPeg++) {
                    // Skip self-connection
                    if (tryPeg === pegIndex) continue;
                    
                    // Generate consistent key (always smaller index first)
                    const key = pegIndex < tryPeg 
                        ? pegIndex * numPegs + tryPeg 
                        : tryPeg * numPegs + pegIndex;
                    
                    // Skip if already used
                    if (used.has(key)) continue;
                    
                    // Get cached pixel indices for this line
                    const pixels = linePixelsCache.get(key);
                    if (!pixels) continue;  // May be null if below minDist
                    
                    // -------------------------------------------------
                    // Calculate brightness difference along the line
                    // -------------------------------------------------
                    // Positive diff = current is brighter than target
                    //               = this area needs more darkening
                    let diff = 0;
                    for (let j = 0; j < pixels.length; j++) {
                        const idx = pixels[j];
                        diff += currentData[idx] - state.targetData[idx];
                    }
                    
                    // Track the best (highest diff) connection
                    if (diff > maxDiff) {
                        maxDiff = diff;
                        bestKey = key;
                        bestPixels = pixels;
                    }
                }
                
                // ---------------------------------------------------------
                // DRAW: If best connection exceeds threshold, draw it
                // ---------------------------------------------------------
                
                if (maxDiff > threshold && bestPixels) {
                    
                    // Update simulated brightness for all pixels on the line
                    for (let j = 0; j < bestPixels.length; j++) {
                        const idx = bestPixels[j];
                        // Subtract darkness, but clamp to 0 (can't go negative)
                        currentData[idx] = Math.max(0, currentData[idx] - darkness);
                    }
                    
                    // Decode the key back to peg indices
                    const p1Idx = Math.floor(bestKey / numPegs);
                    const p2Idx = bestKey % numPegs;
                    
                    // Draw the actual line on the output canvas
                    outCtx.strokeStyle = `rgba(0,0,0,${lineAlpha})`;
                    outCtx.lineWidth = 1;
                    outCtx.beginPath();
                    outCtx.moveTo(
                        pegPositions[p1Idx * 2],      // x1
                        pegPositions[p1Idx * 2 + 1]   // y1
                    );
                    outCtx.lineTo(
                        pegPositions[p2Idx * 2],      // x2
                        pegPositions[p2Idx * 2 + 1]   // y2
                    );
                    outCtx.stroke();
                    
                    // Mark this connection as used
                    used.add(bestKey);
                    lineCount++;
                    improved = true;
                    
                    // -------------------------------------------------
                    // UI Update: Refresh display every 50 lines
                    // -------------------------------------------------
                    if (lineCount % 50 === 0) {
                        const progress = Math.min(100, (lineCount / maxLines) * 100);
                        elements.progressEl.style.width = progress + '%';
                        elements.statLines.textContent = lineCount;
                        elements.statIter.textContent = iterCount;
                        elements.statTime.textContent = formatTime(performance.now() - startTime);
                        
                        // Yield to browser to keep UI responsive
                        await sleep(0);
                    }
                }
                
                // Check if we've hit the max lines limit
                if (lineCount >= maxLines) break mainLoop;
            }
            
            // Update iteration counter display
            elements.statIter.textContent = iterCount;
            
            // ---------------------------------------------------------
            // CONVERGENCE CHECK
            // ---------------------------------------------------------
            // If no strings were drawn this iteration, we've converged
            if (!improved) break;
            
            // Yield to browser between iterations
            await sleep(0);
        }
        
        // =====================================================================
        // COMPLETION
        // =====================================================================
        
        const elapsed = performance.now() - startTime;
        
        // Update final statistics
        elements.progressEl.style.width = '100%';
        elements.statLines.textContent = lineCount;
        elements.statIter.textContent = iterCount;
        elements.statTime.textContent = formatTime(elapsed);
        
        // Reset state
        state.running = false;
        elements.btnStart.disabled = false;
        elements.btnStop.disabled = true;
        elements.btnDownload.disabled = false;
        
        // Set appropriate completion message
        if (state.stopFlag) {
            setStatus(`Stopped: ${lineCount} strings, ${iterCount} iterations`);
        } else if (lineCount >= maxLines) {
            setStatus(`Max lines reached: ${lineCount} strings, ${iterCount} iterations`);
        } else {
            setStatus(`Done! ${lineCount} strings, ${iterCount} iterations`);
        }
    }
    
    // =========================================================================
    // DOWNLOAD FUNCTIONALITY
    // =========================================================================
    
    /**
     * Download the generated string art as a PNG file.
     * 
     * The filename includes the original image name (if available)
     * and a timestamp for uniqueness.
     */
    function downloadResult() {
        // Generate timestamp: YYYY-MM-DD-HH-MM-SS
        const timestamp = new Date().toISOString()
            .slice(0, 19)
            .replace(/[T:]/g, '-');
        
        // Build filename
        const filename = state.fileName 
            ? `string-art-${state.fileName}-${timestamp}.png`
            : `string-art-${timestamp}.png`;
        
        // Create temporary link and trigger download
        const link = document.createElement('a');
        link.download = filename;
        link.href = elements.outCanvas.toDataURL('image/png');
        link.click();
    }
    
    // =========================================================================
    // EVENT LISTENERS
    // =========================================================================
    
    // ----- File Input Handling -----
    
    // Click on drop zone opens file picker
    elements.dropZone.addEventListener('click', () => elements.fileInput.click());
    
    // File selected via picker
    elements.fileInput.addEventListener('change', (e) => {
        if (e.target.files[0]) loadImage(e.target.files[0]);
    });
    
    // Drag over drop zone
    elements.dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();  // Required to allow drop
        elements.dropZone.classList.add('over');
    });
    
    // Drag leaves drop zone
    elements.dropZone.addEventListener('dragleave', () => {
        elements.dropZone.classList.remove('over');
    });
    
    // File dropped on drop zone
    elements.dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        elements.dropZone.classList.remove('over');
        if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
    });
    
    // ----- Slider Value Display Updates -----
    
    elements.numPegsInput.addEventListener('input', function() {
        elements.numPegsVal.textContent = this.value;
    });
    
    elements.lineAlphaInput.addEventListener('input', function() {
        elements.lineAlphaVal.textContent = this.value + '%';
    });
    
    elements.thresholdInput.addEventListener('input', function() {
        elements.thresholdVal.textContent = this.value;
    });
    
    elements.maxLinesInput.addEventListener('input', function() {
        elements.maxLinesVal.textContent = this.value;
    });
    
    // ----- Button Click Handlers -----
    
    elements.btnStart.addEventListener('click', () => {
        if (!state.running) startGeneration();
    });
    
    elements.btnStop.addEventListener('click', () => {
        state.stopFlag = true;
    });
    
    elements.btnDownload.addEventListener('click', downloadResult);
    
    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    
    /**
     * Initialize canvases with placeholder graphics.
     * Shows instructional text before any image is loaded.
     */
    function initCanvases() {
        // Source canvas - dark placeholder
        srcCtx.fillStyle = '#222';
        srcCtx.fillRect(0, 0, SIZE, SIZE);
        srcCtx.strokeStyle = '#444';
        srcCtx.beginPath();
        srcCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        srcCtx.stroke();
        srcCtx.fillStyle = '#666';
        srcCtx.font = '14px sans-serif';
        srcCtx.textAlign = 'center';
        srcCtx.fillText('Upload image', CENTER, CENTER);
        
        // Output canvas - light placeholder
        outCtx.fillStyle = '#f5f5f5';
        outCtx.fillRect(0, 0, SIZE, SIZE);
        outCtx.strokeStyle = '#ddd';
        outCtx.beginPath();
        outCtx.arc(CENTER, CENTER, RADIUS, 0, Math.PI * 2);
        outCtx.stroke();
        outCtx.fillStyle = '#aaa';
        outCtx.font = '14px sans-serif';
        outCtx.textAlign = 'center';
        outCtx.fillText('Result', CENTER, CENTER);
    }
    
    // Run initialization
    initCanvases();
    
})();
</script>
</body>
</html>